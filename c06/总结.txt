第6章 事件 p233 2017-12-03 13：24
6.1、术语说明
事件发生或被触发：当事件发生时，我们通常称之为事件发生或被触发。
事件触发脚本：我们称之为事件触发了函数或者脚本。
6.2、常用事件
	事件：load、unload、error、resize、scroll
	键盘事件：当用户操作键盘时发生，也叫输入事件
		keydown：用户第一次按下一个键（当按住这个键时会反复触发）
		keyup：用户松开了一个键
		keypress：键入了一个字符（当按住这个键时会反复触发）
	鼠标事件：当用户操作鼠标时、触摸板或者触摸屏时发生
		click：用户在同一个元素上按下并松开一个按键
		dblclick：用户在同一个元素上连续两次按下并松开一个按键
		mousedown：用户在一个元素上按下鼠标按键
		mouseup：用户在一个元素上松开鼠标按键
		mousemove：用户移动鼠标（不会发生在触摸屏上）
		mouseover：用户将鼠标移动到一个元素上（不会发生在触摸屏上）
		mouseout：用户将鼠标从一个元素上移开（不会发生在触摸屏上）
	焦点事件：当一个元素（比如链接或者表单域）得到或失去焦点时发生
		focus/focusin：元素得到焦点
		blur/focusout：元素失去焦点
	表单事件：当用户与表单元素进行交互时发生
		input：<input>或<textarea>元素中的值发生了变化（IE9+）或拥有contenteditable属性的元素中的值发生了变化
		change：复选框、单选框或单选按钮的值发生了变化（IE9+）
		submit：用户提交了表单（使用按钮或键盘提交）
		reset：用户点击了表单的重置按妞
		cut：用户从一个表单域中剪切了内容
		copy：用户从一个表单域中复制了内容
		paste：用户向一个表单域中粘贴了内容
		select：用户在一个表单域中选中了一些文本
	变动事件（mutation event）：脚本修改了DOM结构后发生。*未来将会使用变动观察者取而代之（p237页）
		DOMSubtreeModified：文档发生了变化
		DOMNodeInserted：一个节点被插入为另一个节点的直接子节点
		DOMNodeRemoved：一个节点被从另一个节点中移除
		DOMNodeInsertedIntoDocument：一个节点被插入为另一个节点的后代
		DOMNodeRemovedFromDocument：一个节点被从其祖先节点上移除
6.3、事件触发
需要进行三步操作：
	1、选中需要脚本进行事件响应的元素节点；
	2、声明需要在选中节点上响应触发的事件；
	3、指定当事件发生时需要运行的代码。
6.4、UI事件是和浏览器窗口相关的（而不是其中加载的页面），因此它和Window对象而不是元素节点相关联。
6.5、将事件绑定到元素的三种方法
	HTML事件处理程序：on+事件名
		早期的HTML会包含一组属性用来响应它所属元素的事件，这些属性的名称和事件的名称相匹配，值则是当事件发生时需要运行的函数名称；
		比如<a onclick='hide()'>hide</a>，不推荐使用，因为JavaScript和HTML最好是分离的。
	传统的DOM事件处理程序：on+事件名
		它优于HTML的事件处理程序，所以你可以把js从HTML中解救出来。
		优点是所有主流浏览器都支持，缺点是只能在一个事件上附加一个函数。
		使用方法：
			var elUsername = document.getElementById('username');
			elUsername.onblur = checkUsername;
			//checkUsername是函数名，要先于这段代码定义。
	第2级DOM监听器：
		在2000年更新的DOM规范中，引入了事件监听器的概念，如今是最受欢迎的处理事件的方法。
		这种允许一个事件触发多个方法执行，但是不适用于IE8-的浏览器。
		支持穿参数（比如其中的5）：
			elUsername.addEventListener('blur', function(){
				checkUsername(5);
			}, false);
		针对IE8及之前的浏览器，可以使用attachEvent()：
			if(el.addEventListener){
				...
			} else {
				el.attachEvent('onblur', function(){...});
			}
6.6、【自查】-form表单可以跨域提交但是ajax不可以
知乎的问题，有人回答：
	因为原页面用form提交到另一个域名之后，原页面的脚本无法获取新页面中的内容。所以浏览器认为是安全的。
	而ajax是可以读取响应内容的，因此浏览器不能允许你这样做。
	如果你细心的话会发现，其实请求已经发送出去了，你只是拿不动响应而已。
	所以浏览器这个策略的本质是，一个域名的JS，在未经允许的情况下，不得读取另一个域名的内容。
	但是浏览器并不阻止你向另一个域名发送请求。
6.7、事件流
HTML元素都位于另外一些元素中，如果移动鼠标到一个链接上，或者点击一个链接，同样会把鼠标移动到它的父元素上，或者点击它的父元素。
设想<a>元素位于<li>里面，<li>位于<ul>里面，后者位于DOCUMENT-><html>-><body>里面，这样你点击了<a>元素，则会产生：
	事件冒泡：事件从最具体的节点开始向外传播到最宽泛的节点，这是事件流的默认类型，被绝大多数浏览器所支持；
	事件捕获：事件从最宽泛的节点开始向内传播到最具体的节点。这种方式在IE8-的浏览器中不被支持。
只有当代码在一个元素和其祖先元素或后代元素上都有事件处理程序时，事件流才会变得非常重要。
6.8、事件对象
事件对象会作为参数传递给任何事件处理程序或者事件监听器的函数，作为第一参数。其包括如下属性/方法：
	属性				IE5~IE8 	目标
	target			srcElement	事件的目标（具体的元素）
	type			type		发生的事件的类型
	cancelable		不支持		是否可以撤销事件在这个元素上的默认行为目标
	方法					IE5~IE8 		目标	
	preventDefault() 	returnValue		撤销这个事件的默认行为（如果可以撤销的话）
	stopPropagation()	cancelBubble	停止事件继续冒泡或向下捕获的过程
6.9、事件委托
为大量的元素创建事件监听器会造成页面速度下降，不过事件流允许你在父元素上监听事件。
其带来的额外优势是：如果向DOM数中添加了新的元素，那么不需要再向这个新元素添加事件处理程序，因为这个工作已经委托给了一个祖先元素，其可以通过事件对象找到触发事件的原始元素。
检测浏览器是否支持某个方法，可以使用if(e.preventDefault)来测试，如果是false代表不支持，可以转而使用IE8的e.returnValue = false;
如果是属性，则检测if(e.target)来测试，如果是false代表不支持，可以使用IE8的e.srcElement;
如果是e本身，则检测if(e)来测试，如果是false代表不支持，可以使用IE8的window.event;

一个事件处理程序可以返回false，来同时取消默认行为（preventDefault()）和停止冒泡（stopPropagation()）。
6.10、不同的事件类型
在这些地方定义了事件：
	W3C DOM事件：DOM事件规范由W3C管理制定的，有些事件没有涵盖在其中，大部分都是与表单元素有关，现已在HTML5规范中；
	HTML5事件：详细规定了浏览器应该支持的和HTML相关的事件。例如当表单提交或表单元素变动时应该触发的事件；
	BOM事件：作为浏览器对象模型（BOM）的一部分，浏览器厂商也会实现一些相关的事件，通常还未涵盖在W3C事件规范中。
6.11、用户界面事件
用户界面（UI）事件发生在用户与浏览器本身（而不是其中的HTML页面）进行交互的过程中，例如当页面加载完成时，或者浏览器窗口的大小发生变化时。其事件处理程序/监听器附加在浏览器窗口上。
	load：当Web页面加载完成时触发，同样用于其他元素节点的加载事件，比如图片、脚本或对象；
	unload：当Web页面卸载时，该事件会在用户离开页面之前触发；
	error：当浏览器遇到JavaScript错误或不存在的资源时触发，不同浏览器支持差异较大；
	resize：当浏览器窗口改变大小时触发，需要尽可能避免在此事件中使用复杂的代码，因为可能会造成页面暂时失去响应。
	scroll：滚动时触发，可以关联整个页面，也可以特定的元素（比如textarea），同上，避免使用复杂的代码。
下面逐个讲解。
6.12、focus和blur事件
是当一个元素获得焦点或者失去焦点时触发，这两个只支持捕获方式的事件流，而focusin、focusout支持冒泡和捕获方式，但是很多浏览器不支持（比如firefox）。
6.13、鼠标事件
像上面6.2讲解的一样，包括click（当一个元素有焦点时，键入回车也会触发此事件）、dblclick、mousedown、mouseup、mouseover、mouseout、mousemove事件。之所以要把mousedown和mouseup分开，是因为它们通常用于实现拖放功能，或用于游戏控件的开发。
click事件可以用于任何元素，不过最好是用于经常被点击的元素类型。
6.14、事件发生的位置
——————> X
|屏幕
|	页面
|		客户端
|
Y
screenX和screenY属性代表鼠标指针在整个显示器上所处的位置，从屏幕而不是浏览器的左上角开始计算；
pageX和pageY属性代表鼠标指针在整个页面中的位置。页面的顶部可能在可见区域之外，所以即使鼠标指针位于同一位置，页面和客户端的坐标也可能不同；
clientX和clientY属性代表鼠标指针在浏览器可视区域的位置。即使用户想下滚动，使得页面顶部超出了可视范围，也不会影响客户端坐标。
6.15、键盘事件
	input：是在<input>或者<textarea>元素的值发生变化时触发；
	keydown：当用户按下键盘上的任意按键时触发，如按住不放，则会一直触发；
	keypress：当用户按下一个键并在屏幕上反映为一个字符时触发，例如用户按下方向键不会触发。如果用户持续按住一个键，则此事件也会一直触发；
	keyup：当用户松开一个键时触发。
顺序是：keydown>keypress>keyup。当使用keydown或keypress事件时，事件对象有一个名叫keyCode的属性，用于表明用户按下了哪个键，不过是返回这个字符的ASCII码，可使用String.fromCharCode()方法来转化为字符。
6.16、变动事件和变动观察者
比如DOMNodeInserted等变动事件，当脚本大量的修改页面时，会触发很多变动事件，让页面变卡，故用变动观察者取代。
变动观察者的设计理念是：在进行响应之前等待脚本做完所有工作，然后再将DOM的变化批量的报告给脚本（而不是每次都报告），通用可以指定DOM变化的类型，不过浏览器支持的较少。
6.17、HTML5事件
有三个页面级别的事件在HTML5版本的规范中被引入：
	DOMContentLoaded：DOM树形成后触发，可能此时CSS、JavaScript、图片等还在加载中。会早于load事件，该事件可以被附加到window或者document对象上；
	hashchange：当URL的hash值变化时触发，附加在window对象上；
	beforeunload：当页面被卸载之前，在window对象上触发，不过无法决定用户的选择。
最后一个试了下，chrome 版本 61.0.3163.100（正式版本） （64 位）不支持，safari 版本 11.0.1 (12604.3.5.1.1)支持。















